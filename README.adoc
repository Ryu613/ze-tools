= ZE-TOOLS
:toc:

personal lightweight tools library

[NOTE]
====
[.red]##WORK IN PROGRESS##
====

. **ECS**: ECS framework
. **Allocator**: memory pool, allocator with over-aligned supported

== ECS

=== usage

[source, C++]
----
int main() {
    ecs::init();
    ecs::Entity e = ecs::make_entity<Position, Attr>(
        Position{ 50,24,12 },
        Attr{ 120, 100 }
    );
    // add Position & Attr component data to e
    ecs::add_component<Position, Attr>(e, Position{ 20,10,20 }, Attr{ 20, 105 });
    // add Position component data to e
    ecs::add_component<Position>(e, Position{ 20, 10, 20 });
    // add new component Extra to e
    ecs::add_component<Extra>(e, Extra{});
    // add new component Another and add these data to component
    ecs::add_component<Position, Another>(e, Position{ 20,40,20 }, Another{ 1.135656888 });
    // true
    ecs::has_components<Attr>(e);
    // remove Another component from e
    ecs::remove_components<Another>(e);
    // destroy entity e
    ecs::destroy_entity(e);
    // register new system and enable it
    // can add stage & priority in the future
    ecs::register_system<MoveSystem>();
    // trigger specific system's OnUpdate();
    ecs::system_update<MoveSystem>();
    // trigger registered systems' OnUpdate() in order
    ecs::system_update_all();
    // disable system not unregister
    ecs::disable_system<MoveSystem>();
    // re-enable system
    ecs::enable_system<MoveSystem>();
    // unregister system
    //ecs::unregister_system<MoveSystem>();
    return EXIT_SUCCESS;
}
----

== collection

=== sparse_set

benchmark test:

x64, windows10, VS2022, cmake release mode:
====
sparse_set:      ~12-17 ms
unordered_set:   ~88-104 ms

sparse_set is about 6-8 times faster than unordered_set
====

[source, c++]
----
using namespace ze::collection;

constexpr size_t N = 1'000'000;
constexpr size_t TEST_RUNS = 5;

std::vector<uint32_t> generate_random_input(size_t n, uint32_t max_value) {
    std::mt19937 rng(42);
    std::uniform_int_distribution<uint32_t> dist(0, max_value);
    std::vector<uint32_t> data(n);
    std::generate(data.begin(), data.end(), [&]() { return dist(rng); });
    return data;
}

template <typename Func>
long long benchmark(Func func, const std::string& label) {
    auto start = std::chrono::steady_clock::now();
    func();
    auto end = std::chrono::steady_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
    std::cout << label << ": " << duration << " ms" << std::endl;
    return duration;
}

int main() {
    auto data = generate_random_input(N, N * 2);

    for (size_t i = 0; i < TEST_RUNS; ++i) {
        uint32_t max_x = *std::max_element(data.begin(), data.end());
        benchmark([&]() {
            sparse_set<uint32_t> s(max_x + 1);
            // 真实场景模拟：插入前 N/2，查找 N 次，删除 N/4
            for (size_t i = 0; i < N / 2; ++i) s.insert(data[i]);
            for (size_t i = 0; i < N; ++i) s.contains(data[i]);
            for (size_t i = 0; i < N / 4; ++i) s.erase(data[i]);
            }, "sparse_set run " + std::to_string(i + 1));

        benchmark([&]() {
            std::unordered_set<uint32_t> s(max_x + 1);
            for (size_t i = 0; i < N / 2; ++i) s.insert(i);
            for (size_t i = 0; i < N; ++i) {
                [[maybe_unused]] auto it = s.find(i);
            }
            for (size_t i = 0; i < N / 4; ++i) s.erase(i);
            }, "unordered_set run " + std::to_string(i + 1));

        std::cout << "------------------------------" << std::endl;
    }

    return 0;
}
----
